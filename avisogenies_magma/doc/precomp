Some informations about the precomp structure...



precompH :: Assoc
 - "H" :: Curve // The original curve 
 - "sqlvl22" :: Assoc // the square of the theta constants of level (2,2) in genus 2
 - "partial_sth" :: Assoc // Some precomputations about the square of the theta functions of level (2,2) in genus 2. 
 - "P0" :: ThetaNullPoint // the associated theta null point 
 - "Hn" :: Curve // The Rosenhain form of the curve (note that we took an extention field)
 - "Hphi" :: // The map between the curve H and its Rosenhain form Hn over the base field of Hn
 - "HRos" :: SeqEnum // The roots of the f polynomial in Rosenhain form (it includes 0,1). Their order make sense for the Abel-Jacobi map.
 - "Habcdw" :: SeqEnum // The coefficients used when we construct the map from the curve to its rosenhain form

precompHK :: Assoc
// H over the extension where the geometric points of the kernels live
 - "sqlvl22" :: Assoc
 - "partial_sth" :: Assoc 
 - "P0"
 - "Hphi" 
 - "HRos" 
 - "Habcdw" 
 - "Hinfinity" // PointsAtInfinity(H); // est ce ceux de H ou de HK ou est ce que ca revient au meme dans magma
 - "HnJ"
 - "K2"

precompD :: Assoc
 - "red_twotors" :: Assoc
 - "red_symtwotors"
 - "car" :: Assoc
 - "D" :: GrpAb // A finite abelian group for indexing the caracteristics of the theta functions //Exempla: D= AbelianGroup([2: i in [1..g]]) where g is the genus of the curve, for level 2
 - "twotorsion" :: GrpAb // The two torsion subgroup of D. Assume that the invariants of D are divisible by 2
 - "riemann" :: Assoc // Give the dual riemann quadruplet
 - "g" :: RngIntElt // the number of invariants of D

precompl // some informations about the (l,...,l)-isogenies
 - "abstract_subgroups" :: Assoc
 - "l" :: RngIntElt // the l of (l,...,l)-isogenies
 - "coeffs" :: assoc() // For each elements in this preimage, the coefficient of the projective factor due to the coordinates being projective and the use of pseudo-addition in the change of level formulae are divisible by l.
 - "gen" :: SeqEnum // the index of the points used to generate the subgroup of l-torsion (e.g. Dl.i,Dl.i+Dl.j)


precomp
 - "D" = precompD  // 
 - "HK"= precompHK // The underlying hyperelliptic curve over an extension
 - "H" = precompH  // The underlying hyperelliptic curve
 - "l" = precompl  // Some informations about the (l,...,l)-isogenies
 - "ltors_basis" // The basis of l-torsion in Mumford coordinates
 - "ltors" // The l-torsion in Mumford coordinates
 - "ltors_theta" :: Assoc // The l-torsion in Theta coordinates
 - "ltors_basis-ros" :: SeqEnum // A basis of the l-torsion converted to the Rosenhain form
 - "zeta" // a primite l-root of unity, used to compute the logarithm of the Weil pairings
 - "zetalog" // An associative array such that zetalog[zeta^i]=i
 - "ltors_pairings" //the gram matrix of the Weil pairing of the basis of l-torsion
 - "ltors_symplectic-basis" // a symplectic basis
 - "ltors_backtrack" // points in the l-division sequence above the points
of the basis B. Except that some time when we find a point of higher l^n
torsion, we don't update the basis B, so they are points above a different
basis B'. The matrix change between B and B' is given by
ltors_abstract_backtrack
 - "ltors_abstract_backtrack"
 - "ltors_symplectic" // the map from B to a symplectic basis
 - "frob" // FrobeniusPoly(J): the frobenius polynomial over the base field
 - "subgroups" :: SeqEnum :: [[JacHypPt]] // list of subgroups: each subgroups is given by a list of points in the jacobian which are generators of the subgroup. // it seems that the subgroup doesn't need to be rationnal. It seems that it can be of dimension greater than g or non isotropic but in that case I don't know what happen.
 - "thetasubgroups" :: SeqEnum :: [Assoc(GrpAb)] // list of the subgroups. Each subgroups is represented as an associative array indexed by its abstract abelian group. For an element of the abstract abelian group, the element of the associative array is the corresponding theta point. // FIXME

                                                                               
In Arithmetic.m:

- precompute_inverses(~L)

precompute the inverses of the coordinates of a list of theta points, doing
only one division
